---
Title: "Main"
Author: "Thomas Verliefde"
Date: "2019/06/03"
Output: html_document
editor_options:
  chunk_output_type: console
Version: '0.6'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# rm(list=ls())

# load("20190523.RData")

# save.image("20190523.RData")
```

```{r libraries, include=FALSE}

lapply(
  c("plyr","dplyr","tidyr","ggplot2","readr","lme4","afex","lmerTest","emmeans",
    "pbkrtest","purrr","magrittr","cowplot","parallel"),
  require,
  character.only=T
)

```

#######################
# Importing & Cleanup
#######################

###########
## Import
###########

The required datafile (Data_RelAmb02.zip) should be in the working directory.
Note that this datafile is not public on GitHub, but will be on the OSF page of this project.

```{r RAW import, options}

temp <- tempdir()
RAW <- "partialData_RelAmb02.zip" %>% {
  ldply(
    .data = unzip(.,list=T) %>% # create a list of all the files/folders in the zip
      filter(grepl(".+(csv)$",.$Name)) %>% # ignore any files/folders without .csv extension
      arrange(Name %>% desc) %$% Name, # Return only the relevant .csv filenames
    .fun = function(x) {
      unzip(.,files=x,exdir=temp) %>% # Get for each of the .csv filenames the relevant file, and temporary save it
        read_csv(n_max = 1) # Import the .csv file to R
    }
  )
}
rm(temp)

```

```{r RAW Problems, exclude=TRUE}

# temp <- tempdir()
# problemsRAW <- "partialData_RelAmb02.zip" %>% {
#   ldply(
#     .data = unzip(.,list=T) %>% # unzip the 
#       filter(grepl("^(oldVersion)/.+(csv)$",.$Name)) %>% # Ignore any file/folder that is not a .csv file
#       arrange(Name %>% desc) %$% Name, # Returns a 'list' containing the relevant .csv filenames
#     .fun = function(x) unzip(.,files=x,exdir=temp) %>% read_csv
#   )
# }
# rm(temp)
#
# problemsRAW %>%
#   filter(is.na(Objects_Neg1_Dir_Amb)) %>%
#   select(Subject,Condition,Key,firstBlock,firstValence)
# 
# problemsRAW %>% utils::View(.)

```


Subjects 1, 82, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97 have data from during a period in which the software caused problems.
Subjects 83, 84, 85 have no data since the software issue was unresolved at the time.
Subjects 87, 90, 92, 94, 95, 96, & 97 are problematic, as they do not have any direct measures recorded.
The data for latencies is complete though, and can be used for latency analyses.
Further, Subject 87 does not have fully-correct demographics.
That is why their age is indicated as 99 and their study is unknown. Their gender and Language is correct though.

Unrelated:
Subject 145 has no values for some end-of-experiment variables, including one set of direct measures and full demographics.
Subject 107 apparently performed the experiment twice. Only the results from the first experiment will be used.
This is ensured during the import of the data by specifying "n_max = 1".

```{r RAW - Wrangling, options}

RAW %<>%
  mutate_at(
    vars(Age,Handedness,Study,ambiSuggestions),
    funs(
      case_when(
        Subject == 87 ~ NA_character_,
        TRUE ~ .
      )
    )
  ) %>%
  as_tibble %>%
  select(
    -matches("^(practice|experiment)(Primes|Trials)(Objects|Others)$"),
    -hostName
  ) %>%
  mutate(
    Subject = Subject %>% as.numeric %>% factor(levels = unique(.) %>% sort)
  )

```


```{r Trials - Wrangling, options}

dfTrials <- RAW %>%
  gather(
    "fullTrials",
    "outputTrials",
    matches("^(practice|experiment)_(Objects|Others)(\\d)+_(answer|time|prime|target)(Cat)?")
  ) %>%
  select(Subject,Condition,Key,firstBlock,firstValence,fullTrials,outputTrials) %>%
  tidyr::extract(
    fullTrials,
    c("Segment","Block","Trial","components"),
    "^(practice|experiment)_(Objects|Others)(\\d+)_(\\D+)$"
  ) %>%
  group_by(Subject,Trial,Segment,Block) %>%
  spread(
    components,
    outputTrials
  ) %>%
  ungroup %>%
  rename(
    Response = answer,
    primeWord = prime,
    primeCondition = primeCat,
    targetWord = target,
    targetCondition = targetCat,
    RT = time
  ) %>%
  mutate(
    Trial = Trial %>% as.numeric %>% factor(levels = unique(.) %>% sort),
    primeCondition = primeCondition %>%
      recode(
        "0" = "nounPos",
        "1" = "nounNeg",
        "2" = paste0(tolower(Block),"Pos"),
        "3" = paste0(tolower(Block),"Neg"),
        "4" = "letterStr",
      ), # The following two variables could be created with an tidyr::extract(primeCondition,c("primeValence","primeSource"),"^(.+)([A-Z]{1}.+)$")
    primeValence = primeCondition %>%
      gsub("^(.+)([A-Z]{1}.+)$","\\2",.),
    primeSource = primeCondition %>%
      gsub("^(.+)([A-Z]{1}.+)$","\\1",.),
    targetCondition = targetCondition %>%
      recode_factor(
        "0" = "Pos",
        "1" = "Neg"
      ),
    Congruency = case_when(
      primeValence == targetCondition ~ "Congruent",
      primeValence == "Str" ~ "Base",
      TRUE ~ "Incongruent"
    ),
    RT = RT %>% as.numeric,
    logRT = RT %>% as.numeric %>% log,
    Correct = case_when(
      Response == "A" & targetCondition == "Pos" & Key == "Apos" ~ TRUE,
      Response == "A" & targetCondition == "Neg" & Key == "Aneg" ~ TRUE,
      Response == "L" & targetCondition == "Neg" & Key == "Apos" ~ TRUE,
      Response == "L" & targetCondition == "Pos" & Key == "Aneg" ~ TRUE,
      TRUE ~ FALSE
    )
  ) %>%
  group_by(Subject,Segment) %>%
  mutate(
    Accuracy = mean(Correct),
    latencyInclusion = (RT >= 300 & RT <= 3000),
    trialInclusion = latencyInclusion & Correct,
    accInclusion = (1 - mean(trialInclusion)) < 0.83,
    nameExclusion = FALSE,
    subjExclusion = not(accInclusion) | nameExclusion,
    Inclusion = trialInclusion & not(subjExclusion)
  ) %>%
  arrange(Subject,Block,desc(Segment),Trial)

```

```{r Direct - Wrangling, options}

dfDirect <- RAW %>%
  gather(
    "fullDirect",
    "outputDirect",
    matches("^(Objects|Others)_(Neg|Pos)(1|2)_(Dir|Num|Rel)_?(Amb|Neg|Pos)?"),
    matches("^(collect)(Objects|Others)(Neg|Pos)(1|2)$")
  ) %>% 
  select(Subject,Condition,Key,firstBlock,firstValence,fullDirect,outputDirect) %>%
  mutate(
    Subject = Subject %>% as.numeric %>% factor(levels = unique(.) %>% sort),
    fullDirect = sub("(_)|(collect)","",fullDirect)
  ) %>%
  separate(
    fullDirect,
    c("Item","Key"),
    "_",
    extra = "merge",
    fill = "right"
  ) %>%
  replace_na(list(Key = "Name")) %>%
  group_by(Subject,Item) %>%
  spread(Key,outputDirect) %>%
  ungroup %>%
  tidyr::extract(
    Item,
    c("Type","Valence","Id"),
    "^(Objects|Others)(Pos|Neg)(1|2)$"
  ) %>%
  mutate(
    Num = case_when(
      Type == "Objects" ~ NA_character_,
      TRUE ~ Num),
    Dir_Pos = Dir_Pos %>% as.numeric,
    Dir_Neg = Dir_Neg %>% as.numeric,
    Dir_Amb = Dir_Amb %>% as.numeric,
    Griffin = (Dir_Pos + Dir_Neg) / 2 + abs(Dir_Pos - Dir_Neg)
  ) %>%
  rename(
    "Felt" = Dir_Amb,
    "Negative" = Dir_Neg,
    "Positive" = Dir_Pos,
    "Number" = Num,
    "Relation" = Rel
  )
  
```

```{r Time - Wrangling, options}

dfTime <- RAW %>%
  gather(
    "fullTime",
    "outputTime",
    matches("^(time)")
  ) %>%
  select(Subject,Condition,Key,firstBlock,firstValence,fullTime,outputTime) %>%
  mutate(
    fullTime = gsub("time","",fullTime),
    Order = fullTime %>%
      recode(
        "Collect01" = 1,
        "Practice01" = 2 ,
        "Experiment01" = 3,
        "Collect02" = 4,
        "Practice02" = 5,
        "Experiment02" = 6,
        "Explicit" = 7,
        "Demographics" = 8,
        "Ambi" = 9,
        "Total" = 10
      )
  ) %>%
  select(Subject,Order,"Part"=fullTime,"Time"=outputTime) %>%
  arrange(Subject,Order)

```

```{r Demo - Wrangling, options}

dfDemo <- RAW %>%
  select(Subject,Condition,Key,firstBlock,firstValence,Age,Gender,Language,Handedness,Study,ambiSuggestions)

```

```{r Dataframe Output, exclude=TRUE}

dfTrials %>%
  write.csv("trialsData190603.csv")

dfTime %>%
  write.csv("timeData190603.csv")

dfDirect %>%
  write.csv("directData190603.csv")

dfDemo %>%
  write.csv("demoData190603.csv")


```